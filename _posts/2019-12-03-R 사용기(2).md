---
layout: post
title:  "R 사용기(2)"
date:   2019-12-03 22:55:59
author: ivoryRabbit
categories: 개발
comments: true
tag: R
---

## R과 Python

 기억을 더듬어보면, 나는 R을 Python보다 훨씬 일찍 사용하였다. 
 
 2014년도로 거슬러 올라가 한 수리통계학 수업에서는, R을 이용하여 몬테카를로 추정을 학생들에게 보여주고 있다. 당시 통계학 교수님은 원을 중심으로한 넓이가 1인 정사각형 안에 내접원을 그린 후에 원주율 $$\pi$$를 근사하기 위하여 점들을 막 찍어대었다. 그 기억 속의 R은 매우 촌스러웠다. 지금에서야 흔히 사용하는 R studio가 아닌 옛날 R console 창을 띄워놓고, 1000개의 점 좌표들이 하얀 메모장 위에 안쓰럽게 적혀있었다. 그 모습을 봤던 나는 R을 사용하지 않기로 마음먹었다.

 반면 Python은 알고리즘을 공부하기 위해 큰 맘먹고 공부했던 언어이다. 2016년에 대학원을 입학했는데, 주변에 컴퓨터 잘 하는 선배에게 가르쳐 달라고 떼를 썼다. 선배의 과제로 **jupyter notebook**을이용해 **_hang man_** 게임을 만드는데 성공하면서 Python이 좋아졌다.
 
 그 이후 Python에 또 다시 빠지게 된 계기가 있었는데, 무려 2년 후인 2018년이다. Python에는 **pandas** 라는, 데이터를 아주 다루기 쉽게 해주는 패키지가 있다. 특히 pandas profiling report를 이용해 데이터를 보기좋게 요약하는 기능이 쏠쏠하다. 아무튼 이때 처음으로 데이터 과학(data science)이라는 분야를 알게되었고, 취미로라도 개발을 해보고 싶어서 머신러닝을 공부했었다.

 보통 Python을 이용하다보면 **for** 이나 **while** 구문, 그러니까 iteration에 익숙해진다. 그런데 pandas를 이용해 데이터를 막 만지다보면 **for**을 사용하는 것이 최악이라는 것을 느끼게 된다. apply 계열 함수를 사용하거나 numpy처럼 배열(array)연산을 지원하는 함수를 사용하면 **for**을 돌리는 것보다 30배에서 1000배 가까이 빠르다. 
 
 이런 깨달음을 몸소 느낀 후에야 R을 다시 접하게 되었는데, 참으로 다행이라는 생각이 들었다. 왜냐하면 R에서 주로 다룰 자료구조는 data frame이며, 나의 깨달음은 data frame을 잘 활용하는데 있어서 핵심이기 때문이다.
 
 R을 다시 사용하면서 느낀 또 다른 장점은 파이프연산자(%>%)였다. 파이프연산자란, 예를들어 "mean"이라는 함수에 "df"를 input으로 먹이는 경우
```R
mean(df)
```
대신
```R
df %>%
  mean()
```
을 사용하여 스크립트 문법의 간결성을 꾀한다. 참고로 Python의 pandas에서는 dataframe 객체에다가 계속해서 함수를 연결해서 사용할 수 있다. 단, R처럼 보기좋게 개행하기는 힘들다.
```python
df[['column1', 'column2']].groupby(['column1'], as_index = False).mean().sort_values(by = 'column2', ascending = False)
```
대비되는 R 코드는 다음과 같다.

```R
df %>%
  select(column1, column2) %>%
  group_by(column1) %>%
  summarise(column2 = mean(column2)) %>%
  arrange(desc(column2))
```

 또한 시각화에 관해서는 R이 굉장히 편리하다는 생각이 들었다. 처음에는 ggplot2를 이용해 피라미드 그래프를 그리느라 고생했는데, 계속 부딪히면서 알아가다보니 점점 익숙해지고 있다. 하지만 **bokeh** 를 조만간 공부하여 제대하면 갈아탈 예정이다.

---

### R을 이용한 타이타닉 생존 분석

```R
library(titanic)
library(tidyr)
library(dplyr)
library(stringr)
library(ggplot2)

titanic_train %>% 
  names()
titanic_test %>% 
  names()

titanic_train %>% 
  select(-Survived) %>% 
  rbind(titanic_test) ->
  titanic_df

# Pclass
titanic_df %>%
  mutate(Pclass = as.factor(Pclass)) %>% 
  group_by(Pclass) %>% 
  summarise(
    cnt = n()
  ) %>% 
  ggplot(aes(x = Pclass, y = cnt, fill = factor(Pclass))) + 
  geom_col(width = .5, show.legend = F) + 
  ylab('Population')

# Sex
titanic_df %>%
  group_by(Sex) %>% 
  summarise(
    cnt = n()
  ) %>% 
  ggplot(aes(x = Sex, y = cnt, fill = factor(Sex))) + 
  geom_col(width = .5, show.legend = F) + 
  ylab('Population')

# Sex with Survival
titanic_train %>% 
  mutate(Survived = factor(Survived)) %>% 
  group_by(Survived, Sex) %>% 
  summarise(
    cnt = n()
  ) %>% 
  ggplot(aes(x = Survived, y = cnt, fill = Sex)) +
  geom_col(width = .5, position = 'dodge') + 
  ylab('Population') +
  scale_x_discrete(
    labels = c('1' = 'Survived', '0' = 'Dead')
  )
  
```

---

### 데이터 구조에 따른 분석 

독립변수 | 종속변수 | 분석방법
:-- | :-- | --:
범주형 | 범주형 | 카이제곱검정
범주형 | 연속형 | t - 검정 / 분산분석(ANOVA)
연속형 | 범주형 | 로지스틱 회귀분석 / Softmax
연속형 | 연속형 | 선형 / 다중 회귀분석 / 구조방정식
범주형 + 연속형 | 범주형 | 로지스틱 회귀분석 / Decision Tree 기반 학습
범주형 + 연속형 | 연속형 | 공분산분석(ANCOVA)
