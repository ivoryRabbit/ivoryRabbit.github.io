---
layout: post
title: "타이타닉 생존성 분석"
author : ivoryRabbit
data : "`r format(Sys.Date())`"
output:
  html_document: 
    df_print: kable
    fig_height: 6
    fig_width: 10
    theme: spacelab
    toc: yes
    toc_float: yes
  pdf_document:
    fig_height: 6
    fig_width: 10
    toc: no
  word_document:
    fig_height: 6
    fig_width: 9
    toc: no
comments: true
tag: R
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA, size = 'tiny')
```

* * *
# Introduction
* * *

드디어 직장(?)에서 첫 프로젝트를 완성하였다. 야생의 데이터를 다루기 쉽지 않았지만, 무식하게 시간을 때려박아서인지 결과가 나쁘지 않은 것 같다.

프로젝트 전체 기간을 100으로 잡으면, 쿼리를 짜고 데이터를 뽑아내서 전처리를 하는데만 60 이상을 사용한 것 같다. 의외로 분석(t-검정, 상관관계 분석, 랜덤포레스트 등을 사용했음)과 시각화에는 30정도의 시간 밖에 걸리지 않았다. 나머지는 처음에 주제를 잡거나 마지막에 보고서를 작성하는데 투자되었다.

이번 프로젝트를 수행하면서 느꼈던 점을 기록하고 노하우를 복습하기 위해 [**Titanic**](https://www.kaggle.com/c/titanic) 데이터를 분석해 보려고 한다. 다만 타이타닉 생존성 데이터는 내가 수행했던 프로젝트의 데이터와는 스케일과 목적이 다르기 때문에 분석 내용은 다소 상이할 것이다.

분석에 사용할 언어는 프로젝트와 동일하게 **R**을 선택했지만, 타이타닉 생존성 분석에는 가독성이 좋은 **R Markdown**을 사용해 보기로 했다. R에서의 마크다운 운용은  [블로그](https://blog.zarathu.com/posts/2019-01-03-rmarkdown/)를 참고하였다.

* * *
# EDA
* * *

데이터 분석 과정을 부르는데도 크게 두 가지가 있다.

- 탐험적 데이터 분석(Exploratory Data Analysis, EDA)은 일단 데이터가 주어진 후에, 데이터 내에서 새로운 사실을 발견하거나 현 상황을 분석하는 방법이다.

- 확증적 데이터 분석(Confirmatory Data Analysis, CDA)은 밝히고자 하는 현상이나 분석 목적을 먼저 설정한 후, 이에 따라 데이터 수집 방법과 분석 방법을 채택하는 방법이다.

확실히 이 두 개념은 다르지만, 경험상 **EDA를 하면 저절로 CDA를 하게 된다**고 생각한다. 그래서 섹션의 제목도 EDA로 정했다.

참고로 인터넷을 찾아보면 더 많은 분석방법이 있다.

- 묘사적 데이터 분석(Descriptive Data Analysis)
- 예측적 데이터 분석(Predictive Data Analysis)
- 정성적 데이터 분석(Qualitative Data Analysis)
- 정량적 데이터 분석(Quantitative Data Analysis)

* * *
## 1. 데이터 불러오기(Load Data)
* * *

우선 분석에 필요한 라이브러리를 불러오자. 
```{r eval=F}
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
```


- **dplyr**과 **tidyr**은 R의 대표적 자료구조 **dataframe**을 사용하기에 매우 유용한 패키지이다. 특히 dplyr의 파이프연산자 $$\text{%>%}$$는 코드를 작성하고 읽는데 굉장한 도움을 준다.

- **stringr**은 문자열 데이터를 유용하게 처리할 수 있는 패키지로, **정규표현식(regex)**을 숙지하고 있다면 매우 매우 유용하게 사용할 수 있다.

- **ggplot2**는 R의 대표적인 시각화 패키지이다.

참고로 위 4개의 패키지는 **tidyverse**라는 패키지로 한꺼번에 불러올 수 있다.
```{r}
library(tidyverse)
```

이제 타이타닉(titanic) 데이터를 불러오자. **titanic** 패키지 안에 있는 데이터를 확인하려면 다음 코드를 실행하면 된다.
```{r}
library(titanic)

data(package = 'titanic')$result[,'Item']
```

먼저 **titanic_train**이라고 적혀있는 데이터를 살펴보자. **knitr::kable** 패키지를 사용하면 데이터를 좀 더 예쁜 형태로 가져올 수 있다. R Markdown에는 output option으로 kable 형태의 출력을 지정할 수 있다.(위 블로그 참고)
```{r}
class(titanic_train)
titanic_train %>% 
  head() %>% 
  knitr::kable()
```

보다시피 class가 **data.frame**이라고 적혀있는데 앞서 말한 R의 대표적인 자료구조 dataframe이다. 

행렬 형태로 깔끔(tidy)하게 보여주는데, 이 때 행(row)은 **관측점(observation)**, 열(column)은 **변수(variable)** 혹은 **특징(featrue)**라고 부른다. 우리의 타이타닉 데이터에서는 각각의 관측점이 "사람"이라는 개체이고 변수가 그 사람의 인적정보를 나타내고 있다.

참고로 dataframe에 관해서는 다음 키워드를 공부하면 좋다고 생각한다.

- 관측점은 DBMS에서의 **entity**와 비슷한 개념이다. 즉, 관측점은 사람뿐만 아니라 시간, 행위, 장소 등이 될 수 있다.
- **Tidy data**라는 개념을 알아두면 좋다.
- Python에서는 **pandas**라는 패키지를 불러오면 dataframe을 이용할 수 있다.

  
* * *
## 2. 데이터 요약(Data Summary)
* * *

나머지 데이터를 이제 확인해보자. R에서는 다음과 같은 방법으로 변수를 지정한다.
```{r eval = F}
x <- 2
2 -> x
```
물론 다른 언어들처럼 **=**를 사용할 수도 있다.
```{r eval = F}
x = 2
```

우선 train data set과 test data set의 변수를 확인하고 하나의 데이터프레임에 저장한다. test data set에는 train data set에만 있는 생존여부(Survived) 변수를 인위적으로 **NA** 처리하여 넣어준다.
```{r}
train <- titanic_train 
train %>% 
  names()

test <- titanic_test
test %>% 
  names

test %>%
  mutate(Survived = NA) ->
  test

train %>% 
  rbind(test) ->
  df
```

변수들을 정리하면 다음과 같다.

- 승객번호(PassengerId)
- 생존여부(Survived)
- 승선등급(Pclass)
- 성명(Name)
- 성별(Sex)
- 나이(Age)
- 동승한 형제자매 혹은 배우자 수(SibSp)
- 동승한 부모 혹은 자식 수(Parch)
- 티켓번호(Ticket)
- 승선요금(Fare)
- 객실번호(Cabin)
- 승선항구(Embarked)


**is.na()** 함수를 이용하면 결측된 데이터를 볼 수 있다. 이 방법으론 공백이나 0으로 처리된 결측은 찾지 못한다. 그래서 변수 별로 데이터를 확인해볼 필요가 있다.
```{r}
df %>% 
  is.na() %>% 
  colSums()
```

**str** 혹은 **summary()** 함수를 이용하면 요약된 데이터를 볼 수 있다.
```{r}
str(df)
summary(df)
```

* * *
## 3. 데이터 탐색(Data Overview)
* * *

프로젝트를 진행할 때는 접근 가능한 모든 데이터를 다른 사람에게 잘 설명할 수 있을 정도로 빠삭하게 공부했었다. 이번도 마찬가지로, 분석을 시작하기 전에 데이터와 조금 친해져야할 필요가 있다.

각 변수마다 유형(variable type), 척도(scale), 결측치(missing value)를 직접 확인하면서, 가능하다면 시각화도 시도해볼 것이다. 

* * *
### 1. 승선등급(Pclass)
* * *

승객번호는  변수명이 생소한 **승선등급(Pclass)**부터 보자. 승선등급(Pclass)은 승객들의 승선등급으로, 비행기에서의 비지니스 클래스 또는 이코노미 클래스와 비슷하다. Pclass의 숫자 1, 2, 3은 각각 1등석, 2등석, 3등석에 대응한다. 우리는 이처럼 데이터의 값이 1, 2, 3으로 되어있다고 해서 변수 유형이 정수형(integer)이라고 단순하게 생각해선 안된다.

각 승선등급(Pclass)에 따른 인원수를 시각화하였다. ggplot2는 막대그래프를 그리는데 있어서 **geom_bar**와 **geom_col**을 지원하고 있다. **geom_bar**는 (tidy) data를, **geom_col**는 XY 체계 혹은 집계(aggregation) 데이터를 시각화해준다. 두 경우 모두 코드를 준비했으니 서로 비교해보자.

```{r}
df %>%
  mutate(Pclass = factor(Pclass)) %>% 
  ggplot(
    aes(x = Pclass, fill = factor(Pclass))
  ) + 
  geom_bar(width = .5, show.legend = F) + 
  geom_text(
    aes(label = ..count..),
    stat = 'count',
    vjust = 2
  ) +
  scale_x_discrete(
    labels = c('1' = '1st', '2' = '2nd', '3' = '3rd')
  ) +
  ylab('# of people')

df %>%
  mutate(Pclass = factor(Pclass)) %>% 
  group_by(Pclass) %>% # pivot
  summarise(
    cnt = n() # aggregation
  ) %>% 
  ggplot(
    aes(x = Pclass, y = cnt, fill = factor(Pclass))
  ) + 
  geom_col(width = .5, show.legend = F) + 
  geom_text(
    aes(label = cnt),
    vjust = 2
  ) +
  scale_x_discrete(
    labels = c('1' = '1st', '2' = '2nd', '3' = '3rd')
  ) +
  ylab('# of people')
```

혹시 코드가 어렵게 느껴진다면, 첫줄부터 파이프연산자 단위로 한줄한줄 추가하면서 실행해보길 바란다.

* * *
### 2. 성명(Name)
* * *

**성명(Name)**이라는 변수는 성(Last Name) + 쉼표(,) + (Mr, Mrs, Miss 등) + 마침표(.) + 이름(First Name)으로 구성되어 있는 것을 확인할 수 있다. **stringr** 패키지의 함수들과 **정규표현식(regex)**를 이용하면 편리하다.
```{r}
df %>% 
  select(Name) %>% 
  head(5)

df %>% 
  summarise(
    쉼표개수 = sum(str_detect(Name, ',')),
    마침표개수 = sum(str_detect(Name, ',')),
    데이터개수 = n()
  )
  
df %>% 
  mutate(
    Last_Name = str_split_fixed(Name, '[,|.]', 3)[, 1] %>% str_trim(),
    First_Name = str_split_fixed(Name, '[,|.]', 3)[, 3] %>% str_trim(),
    Honorific = str_split_fixed(Name, '[,|.]', 3)[, 2] %>% str_trim()
  ) ->
  df
```

아무래도 이름(First Name) 보다는 성(Last Name)과 경칭(Honorific) 변수가 더 유용할 것 같다. 이런 변수들은 생존여부(Survived)와의 관계를 직접 계산해보면서 뺄지 말지 결정하면 된다.

```{r}
df %>% 
  select(Last_Name) %>% 
  slice(1, 5, 15, 25, 35)

df %>% 
  select(Honorific) %>% 
  table()
```

자세히보면 경칭(Honorific)에 익숙치 않은 단어들이 있다. 위키피디아를 참고하여 경칭의 의미를 찾아보았다.

| Honorific | 의미 | Honorific | 의미 |
|:---:|---:|:---:|---:|
| Mr | 남성 | Ms | 여성 |
| Don | 남성 | Lady | 여성 |
| Col | 남성 | Mrs | 기혼 여성 |
| Master | 소년 | Mme | 기혼 여성 |
| Rev | 목사 | Dona | 기혼 여성 |
| Capt | 공군 대령 | Miss | 미혼 여성 |
| Major | 소령 | Mlle | 기혼 여성 |
| Sir | 장교 | the Countess | 백작부인 |
| | | Jonkheer | 귀족 여성 |

비슷한 의미를 가진 단어들이 많으므로 범주를 줄여보자. 나중에는 경칭(Honorific)과 생존성의 관계를 파악하여 한번 더 정리할 것이다.
```{r}
df %>% 
  mutate(
    Honorific = ifelse(Honorific == 'Lady', 'Mrs' , Honorific), # 데이터에서 Mrs임이 명시됨
    Honorific = ifelse(Honorific %in% c('Mme', 'the Countess', 'Jonkheer', 'Dona'), 'Mrs', Honorific),
    Honorific = ifelse(Honorific == 'Mlle', 'Miss', Honorific),
    Honorific = ifelse(Honorific %in% c('Don', 'Col'), 'Mr', Honorific)
  ) ->
  df

df %>% 
  select(Honorific) %>% 
  table()
```

* * *
### 3. 성별(Sex) & 나이(Age)
* * *

이제 **성별(Sex)**와 **나이(Age)**를 살펴보자. 나이(Age) 같은 경우에는 결측이 있으므로, 우선 결측이 없는 관측치를 대상으로 시각화한다. 참고로 나이(Age) 변수는 정수(integer)가 아니다.

```{r}
df %>% 
  filter(Age != as.integer(Age)) %>% 
  select(Age) %>% 
  head(5)
```

```{r}
df %>%
  group_by(Sex) %>% 
  summarise(cnt = n()) %>% 
  ggplot(aes(x = Sex, y = cnt, fill = factor(Sex))) + 
  geom_col(width = .5, show.legend = F) + 
  geom_text(
    aes(x = Sex, y = cnt, label = cnt),
    vjust = 2
  ) +
  ylab('# of people')
```

```{r}
df %>% 
  filter(!is.na(Age)) %>% 
  mutate(
    age_intervals = cut(
      Age,
      breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90),
      labels = c('00-09', '10-19', '20-29', '30-39', '40-49', '50-59', '60-69', '70-79', '80-89'),
      right = F
    )
  ) %>% 
  ggplot(aes(x = age_intervals, fill = age_intervals)) +
  geom_bar() + 
  geom_text(
    aes(label = ..count..),
    stat = 'count',
    vjust = 2
  ) +
  ylab('# of people')
```

* * *
### 피라미드(pyramid) & 바이올린(violin)
* * *

나이(Age)와 성별(Sex) 두 변수를 한꺼번에 피라미드 플롯(pyramid plot)로 그릴 수 있다.

```{r}
df %>% 
  filter(!is.na(Age)) %>% 
  mutate(
    age_intervals = cut(
      Age,
      breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90),
      labels = c('00-09', '10-19', '20-29', '30-39', '40-49', '50-59', '60-69', '70-79', '80-89'),
      right = F
    )
  ) %>% 
  ggplot(aes(x = age_intervals, fill = Sex)) +
  geom_bar(data = . %>% subset(Sex == 'male'), aes(y = ..count..)) +
  geom_bar(data = . %>% subset(Sex == 'female'), aes(y = ..count.. * -1)) +
  scale_y_continuous(
    limits = c(-250, 250),
    breaks = seq(-250, 250, 50),
    labels = abs
  ) + 
  xlab(NULL) + ylab('# of people') +
  coord_flip()
```

참고로 피라미드 플롯을 좀 더 깔끔하게 만드려면 다음과 같이 하면된다.

```{r message=F}
library(gridExtra)

df %>% 
  filter(!is.na(Age)) %>% 
  mutate(
    age_intervals = cut(
      Age,
      breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90),
      labels = c('00-09', '10-19', '20-29', '30-39', '40-49', '50-59', '60-69', '70-79', '80-89'),
      right = F
    )
  ) %>% 
  ggplot(aes(x = age_intervals, fill = Sex)) ->
  p

p +
  geom_bar(data = . %>% subset(Sex == 'female'), aes(y = ..count.. * -1)) +
  scale_y_continuous(
    limits = c(-250, 0),
    breaks = seq(-250, 0, 50),
    labels = abs
  ) + 
  labs(x = NULL, y = NULL) +
  theme_minimal() +
  theme(
    legend.position = 'none',
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(), 
  ) +
  coord_flip() ->
  p.female

p +
  geom_bar(data = . %>% subset(Sex == 'male'), aes(y = ..count.., fill = Sex)) +
  scale_y_continuous(
    limits = c(0, 250),
    breaks = seq(0, 250, 50),
    labels = abs
  ) + 
  labs(x = NULL, y = NULL) +
  theme_minimal() +
  theme(
    axis.ticks.y = element_blank()
  ) +
  scale_fill_manual(
    name = 'Sex',
    values = c(female = '#F8766D', male = '#00BFC4'),
    limits = c('female', 'male'),
    labels = c('female', 'male')
  ) +
  coord_flip() ->
  p.male

grid.arrange(
  p.female,
  p.male,
  widths = c(.4, .6),
  ncol=2
  )
```

위의 피라미드 그래프는 **ggpol::facet_share**을 이용해서도 그릴 수 있다. 하지만 이 방법은 **geom_bar** 혹은 **stat** 계열 함수를 이용할 때, "y-axis limits scaling"이 불가능하다. "y-axis limits scaling"을 위해선 데이터를 집계한 후, **geom_blank**를 이용해 dummy data를 집어 넣어야 하는 불편함이 있다.

```{r}
library(ggpol)

df %>% 
  filter(!is.na(Age)) %>% 
  mutate(
    age_intervals = cut(
      Age,
      breaks = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90),
      c('01-10', '11-20', '21-30', '31-40', '41-50', '51-60', '61-70', '71-80', '81-90')
    )
  ) %>% 
  group_by(Sex, age_intervals) %>% 
  summarise(cnt = n()) %>% 
  ggplot(aes(x = age_intervals, y = cnt, fill = Sex)) +
  geom_blank(
    data = data.frame(
      age_intervals = c('01-10', '01-10'), 
      Sex = c('male', 'female'),
      cnt = c(250, -250)
    )
  ) + 
  geom_col(data = . %>% subset(Sex == 'male'), aes(y = cnt)) +
  geom_col(data = . %>% subset(Sex == 'female'), aes(y = -1 * cnt), position = 'identity') +
  coord_flip() +
  facet_share(
    ~Sex,
    dir = 'h', 
    scales = 'free',
    reverse_num = T
  ) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    strip.text.x = element_blank()
  ) +
  labs(x = NULL, y = NULL)
```

나이(Age)와 성별(Sex), 승선등급(Pclass) 세 개의 변수를 한번에 바이올린 플롯(violin plot)로 그릴 수 있다.

```{r}
df %>% 
  filter(!is.na(Age)) %>% 
  ggplot(aes(x = factor(Pclass), y = Age, fill = Sex)) +
  geom_violin() +
  xlab('Pclass') +
  scale_x_discrete(
    labels = c('1st', '2nd', '3rd')
  )
```

아쉽게도 ggplot2의 바이올린 플롯은 Python **seaborn**처럼 split되지 않는다. 그래서 **geom_violin**을 사용하기 보다 **geom_polygon**을 이용하여 바이올린 플롯처럼 보이게 만들어야 한다.

```{r}
df %>%
  filter(!is.na(Age)) %>% 
  mutate(Pclass = factor(Pclass)) %>% 
  group_by(Pclass, Sex) %>% 
  do(
    data.frame(loc = density(.$Age)$x, dens = density(.$Age)$y)
  ) %>% 
  mutate(
    loc = pmax(loc, min(df$Age, na.rm = T)),
    loc = pmin(loc, max(df$Age, na.rm = T)),
    dens = ifelse(Sex == 'female', dens * -8, dens * 8),
    dens = ifelse(Pclass == 2, dens + 1, dens),
    dens = ifelse(Pclass == 3, dens + 2, dens)
  ) %>% 
  ggplot(aes(dens, loc, fill = Sex, group = interaction(Sex, Pclass))) +
  geom_polygon(col = 1) +
  scale_x_continuous(limits = c(-.5, 2.5), breaks = seq(0, 2, 1), labels = c('1st', '2nd', '3rd')) +
  scale_y_continuous(breaks = seq(0, 100, 20), labels = seq(0, 100, 20)) +
  labs(x = 'Pclass', y = 'Age') +
  theme_minimal()
```

* * *
### 4. 동승가족 수(ibSp & Parch)
* * *
이제 동승한 가족들 수를 관찰해보자. SibSp는 아마도 sibling/spouse의 줄임이고 Parch는 parent/child의 줄임으로 보인다.
```{r}
df %>%
  gather(FamType, FamNum, SibSp, Parch) %>% 
  ggplot(aes(x = as.character(FamNum), fill = FamType)) + 
  geom_bar(position = position_dodge(preserve = 'single')) + 
  labs(x = 'Family number', y = '# of people') +
  guides(fill = guide_legend(title = 'Family type'))

df %>% 
  mutate(FamNum = SibSp + Parch) %>% 
  ggplot(aes(x = as.character(FamNum), fill = as.factor(FamNum))) +
  stat_count(show.legend = F) +
  scale_x_discrete(
    limits = as.character(0: 10)
  ) +
  labs(x = 'Family number', y = '# of people')
  
```
앞서 구한 성(Last Name) 변수와 비교해보자. 같은 성씨를 가진 사람의 수와 가족의 수가 얼추 일치하지만, 성씨가 똑같은 사람이 있을 경우도 존재한다. 탑승자 별로 가족 구성 정보을 뽑아내고 싶다면 성(Last Name)뿐만 아니라 다른 변수들도 필요할 것이다.
```{r}
df %>% 
  group_by(Last_Name) %>% 
  summarise(
    LNNum = n()
  ) %>% 
  right_join(df, by = 'Last_Name') %>% 
  mutate(
    FamNum = SibSp + Parch + 1 # 자기자신 포함
  ) %>% 
  select(Name, LNNum, FamNum, Pclass, Sex, Age, Cabin, Embarked, Ticket) %>% 
  arrange(Name) %>% 
  head(10)
```
* * *
### 5. 승선요금(Fare)
* * *

**승선요금(Fare)**에는 결측치가 하나 포함되어 있다. 생존여부(Survived)가 결측인 것으로 보아 train data set이 아닌 test data set에 포함된 데이터이다.

```{r}
df %>% 
  filter(is.na(Fare)) %>% 
  select(Name, Sex, Age, Pclass, Cabin, Embarked, Fare, Survived)
```

승선요금(Fare)가 0인 사람들도 있는데, 결측인지 아니면 정말 공짜로 탔는지 구분이 필요하다. 만약 공짜로 탔다면 선원일 가능성이 높다.

```{r}
df %>% 
  filter(Fare == 0) %>% 
  select(Name, Sex, Age, Pclass, Embarked, Cabin, Survived) %>% 
  head(5)
```

승선요금(Fare)와 가장 연관성이 높아보이는 승선등급(Pclass)을 함께 보자.

```{r}
df %>% 
  filter(!is.na(Fare), Fare != 0) %>% 
  group_by(Pclass) %>% 
  summarise(
    max_Fare = max(Fare),
    mean_Fare = mean(Fare),
    min_Fare = min(Fare)
  )
```

확실히 승선등급(Pclass)에 따라 승선요금(Fare)의 차이가 보인다. 하나 더 흥미로운 점은 승선항구(Embarked) 또한 승선요금(Fare)의 차이가 발생한다는 것이다.

```{r}
df %>% 
  filter(!is.na(Fare), Fare != 0) %>% 
  group_by(Embarked) %>% 
  summarise(
    max_Fare = max(Fare),
    mean_Fare = mean(Fare),
    min_Fare = min(Fare)
  ) %>% 
  arrange(factor(Embarked, levels = c('S', 'C', 'Q')))
```

* * *
### 6. 객실번호(Cabin)
* * *

다음은 **객실번호(Cabin)**이다. 겉보기엔 영문+숫자 조합이지만, 객실번호(Cabin)가 여러개인 사람들도 존재한다. 그리고 특이하게 영문 F가 붙은 객실번호도 있다. [문서](https://www.encyclopedia-titanica.org/titanic-deckplans/a-deck.html)에 따르면 이것이 갑판(Deck)의 번호임을 알 수 있다.
```{r}
df %>% 
  select(Cabin) %>% 
  slice(1, 2, 28, 76, 340, 1001) # equals to filter(row_number() = 28)
```

즐거운(?) 전처리를 살짝 해보자. 다음과 같은 방법으로 객실번호(Cabin) 데이터를 최대한 분리시킬 수 있다.

```{r}
df %>% 
  mutate(
    Cabin1 = str_extract(Cabin, '[A-Z]{1}[:digit:]+'),
    Cabin2 = str_remove(Cabin, Cabin1) %>% str_extract('[A-Z]{1}[:digit:]+'),
    Cabin3 = str_remove_all(Cabin, paste(Cabin1, Cabin2, sep = '|')) %>% str_extract('[A-Z]{1}[:digit:]+'),
    Cabin4 = str_remove_all(Cabin, paste(Cabin1, Cabin2, Cabin3, sep = '|')) %>%  str_extract('[A-Z]{1}[:digit:]+'),
    Deck = str_sub(Cabin, 1, 1),
    Cabin_Type = str_sub(Cabin1, 1, 1)
  ) ->
  df
```

```{r}
df %>% 
  filter(Cabin_Type != '') %>% 
  ggplot(aes(x = Cabin_Type, fill = Cabin_Type)) +
  geom_bar(show.legend = F) +
  geom_text(aes(y = ..count.. + 3, label = ..count..), stat = 'count') +
  ylab('# of people')
```

참고로 객실번호(Cabin) 또한 승선등급(Pclass)과 관련있어 보인다.

```{r}
df %>% 
  group_by(Cabin_Type) %>% 
  summarise(
    class1 = sum(Pclass == 1),
    class2 = sum(Pclass == 2),
    class3 = sum(Pclass == 3)
  )
```

데이터에 따르면 Ryerson 가족들이 4개의 객실을 이용했다. 5개 이상의 객실을 이용한 사람은 없으므로 다음 변수로 넘어가자.

```{r}
df %>% 
  filter(!is.na(Cabin4)) %>% 
  select(Survived, Pclass, Name, Cabin1, Cabin2, Cabin3, Cabin4)
```

* * *
### 7. 승선항구(Embarked)
* * *

**승선항구(Embarked)**는 S, C, Q가 각각 Southampton, Cherbourg, Queenstown를 의미하며, 공백으로 처리된 데이터도 포함하고 있다.

- 사우스앰프턴(Southampton, 영국) 항구는 대서양을 건너기 위한 타이타닉 호의 출발지
- 셰르부르(Cherbourg, 프랑스) 항구는 타이타닉 호의 첫번째 경유지
- 퀸스타운(Queenstown, 아일랜드) 항구는 타이타닉 호의 두번째 경유지

데이터를 살펴보면, 총 두 명의 사람이 승선항구(Embarked)가 공백 처리되어 있는데, 사우스앰프턴(S)에서 승선했는지, 셰르부르(C)에서 승선했는지 판단하기 힘들다. 38세의 여성 Icard, Miss. Amelie와 62세의 여성 Stone, Mrs. George Nelson은 가족 관계가 아님에도 함께 같은 객실을 쓴 것으로 보아, 둘 중 한명은 하녀 혹은 유모였을 것이다.

```{r}
df %>% 
  select(Embarked) %>% 
  unique()

df %>% 
  filter(Embarked == '') %>% 
  select(Pclass, Name, Sex, Age, SibSp, Parch, Fare, Cabin, Embarked)

df %>% 
  filter(Pclass == 1, Cabin_Type == 'B', str_length(Ticket) == 6, Fare > 40, is.na(Cabin2)) %>% 
  select(Pclass, Ticket, Fare, Cabin, Embarked, Honorific, Age) %>% 
  arrange(Fare)
```

참고로 **ggplot2**에서 x축(x-axis)을 재정렬하는데는 세 가지 방법이 있다. 하나는 아래처럼 **mutate**와 factor을 이용해 순서를 강제해 주는 방법이다. 다른 방법으로는 **ggplot** 함수에서 factor을 이용하거나 **scale_x_discrete** 함수에서 limit을 조정하면 된다. 아래에서 mutate 방법을 이용한 이유는 x축 뿐만아니라 fill까지 한꺼번에 순서를 지정하기 위함이다.

```{r}
df %>% 
  filter(Embarked != '') %>% 
  mutate(Embarked = factor(Embarked, level = c('S', 'C', 'Q'))) %>% 
  ggplot(aes(x = Embarked, fill = Embarked)) +
  geom_bar(show.legend = F, width = .5) +
  geom_text(aes(label = ..count..), stat = 'count', vjust = 2) +
  ylab('# of people')
```

* * *
### 8. 승객번호(PassengerId)
* * *

**승객번호(PassengerId)**를 간단히 살펴보자. 승객번호(PassengerId)의 구간 별 생존율을 보면, 100번 대의 사람들의 생존율이 조금 낮다. 이를 활용할 방법을 생각해 보는 것도 좋겠다. 

```{r message = F, warning=F}
library(scales)

df %>% 
  filter(!is.na(Survived)) %>% 
  mutate(
    ID_intervals = cut(
      PassengerId,
      breaks = seq(0, 1400, 100),
      labels = seq(0, 1300, 100)
    )
  ) %>% 
  group_by(ID_intervals) %>% 
  summarise(
    생존율 = percent(sum(Survived == 1) / n())
  )
```


* * *
### 9. 티켓번호(Ticket)
* * *

**티켓번호(Ticket)**를 간단히 살펴보자. 티켓번호(Ticket)의 길이와 승선항구(Embarked) 간에도 규칙이 있어보인다. 또한 티켓번호(Ticket) 앞에 영문이 붙어 있는 경우, 이 영문과 생존율 사이에도 어떤 규칙이 있는지 생각해보자.

```{r message = F, warning=F}
library(reshape2)

df %>% 
  filter(Embarked != '') %>% 
  mutate(
    Ticket_len = str_length(Ticket)
  ) %>%  
  dcast(Ticket_len ~ Embarked)

df %>% 
  filter(!is.na(Survived)) %>% 
  mutate(
    Ticket_Type = str_remove_all(Ticket, '[0-9]|[:punct:]') %>% str_to_lower() %>% str_trim()
  ) %>% 
  group_by(Ticket_Type) %>% 
  summarise(
    생존율 = percent(sum(Survived == 1) / n()),
    인원수 = n()
  ) %>% 
  arrange(desc(인원수)) %>% 
  head(10)
```

* * *
### 10. 변수 척도(Scale)
* * *

아래 테이블을 보면, 승선요금(Fare)을 제외한 모든 변수들이 categorical하다. 우리는 문자열(String)로 이루어진 변수들을 모두 **categorical encoding** 혹은 **one-hot encoding**해 줄 필요가 있다.

| 변수명 | Type | Scale | Missing value |
|:--- |:---:|:---:|---:|
| PassengerId | discrete | norminal | None |
| Survived | binary | norminal | all test set |
| Pclass | discrete | ordinal | None |
| Name | categorical | - | None |
| Sex | binary | norminal | None |
| Age | continuous | ratio | some NA's |
| SibSp | discrete | ratio | None |
| Parch | discrete | ratio | None |
| Ticket | categorical | normial | some blanks |
| Fare | continuous | ratio | some NA's, some 0's
| Cabin | categorical | ordinal | some blanks |
| Embarked | categorical | normial | some blanks |

* * *
# Feature Engineering
* * *

**Feature**은 통계에서의 변수(variable)와 동일한 의미를 가진 머신러닝 용어이다. 우리는 생존여부(Survived)를 예측하기 위해 머신러닝 모델을 사용할 것이므로 피처 엔지니어링을 수행하여야 한다.

앞에서의 EDA를 토대로, 어떤 특징을 선택하고 제거할지 결정하고, 원천 데이터(raw data)로 부터 새로운 데이터를 뽑아낼 수 있는지 확인해보자. 각 변수가 우리의 예측 대상인 생존여부(Survived)와 얼마나 연관성이 있을지 확인해보고 시각화할 것이다. 이러한 과정도 EDA로 볼 수 있지만, 한꺼번에 너무 많은 개념을 수행하면 정리가 힘들기 때문에 파트를 나누어서 진행하였다.

피처 엔지니어링 과정은 크게 세 가지가 있다. 암기할 필요없이 이런 것들이 있다 정도만 알면 될 것 같다.

- Feature Extraction: 원천 데이터(raw data) 속에 있는 latent feature를 이끌어 내는 과정
  - PCA: SVD같이 행렬분해를 통해 차원을 축소시키는 방법
  - Auto-Regressive model: PSD 등을 이용하여 차원을 축소하거나 noise를 없애는 방법
  - Encoder-Decoder model: 딥러닝을 이용하여 차원을 줄이거나 늘이는 방법

- Feature Selection: 예측에 영향을 미치는 feature을 고르거나, 혼란을 주는 feature를 제거
  - Statistical method: ANOVA, regression, A/B test, hypothesis test 등을 이용
  - Machine learning: decision tree 기반의 모델을 사용해서 feature importance를 측정

- Feature Generation: 변수를 합치거나 쪼개어 새로운 변수를 만드는 과정

* * *
### 1. 특징 생성(Feature Generation)
* * *

우선 특징 추출(Feature extraction)은 우리의 데이터와는 거리가 먼 방법이라 생각한다. 특징 추출을 사용하려면 음성이나 이미지처럼 변수들을 관통하는 어떤 "무언가"가 있어야 한다. 타이타닉 사고에서 승객들의 죽음에 영향을 끼친, 어떤 숨겨진 "무언가"가 있다곤 느껴지진 않는다.

특징 생성(Feature generation)은 앞선 EDA 과정에서 거의 다 수행했다고 볼 수 있다.

```{r}
df %>% 
  names()
```

```{r}
df %>% 
  filter(Fare < 10) %>% 
  select(Fare, Pclass, Age, Sex, Cabin_Type, Deck, Honorific)

df %>% 
  filter(Age < 10) %>% 
  select()
```

* * *
### 2. 특징 선택(Feature Selection)
* * *

* * *
# Data Preprocessing
* * *

데이터 전처리 또한 EDA로 변수를 하나하나 뜯어볼 때 작업하려고 했었다. 왜냐하면 데이터 탐색과 시각화를 하는 목적이 바로 data preprocessing과 feature engineering이기 때문이다. 하지만 피처 엔지니어링과 마찬가지로 개념 정리를 위해 파트를 나누었다. 

데이터 전처리 과정에는 크게 세 가지 과정이 있다. 마찬가지로 암기할 필요없이 이러한 것들이 있다는 정도만 알면 된다. 내가 실제로 데이터를 다루어 보면서 필요했던 것들이나 직접 사용했던 것들을 정리한 것이다.

- Missing data imputation: 결측으로 처리된 데이터를 제거하거나 대체하는 작업
  - Statistical imputation: representative values, multivarite gausian model, gausian mixture model 등 이용
  - Unsupervised machine learning: KNN, K-mean clustering 등 이용
  - Supervised machine learning: random forest, support vecotr machine 등 이용

- Categorical variable encoding: 범주형 변수를 수(numeric)로 변환하되, 학습하기 편리하게 정제
  - One-hot encoding 
  - Label encoding
  - [Survey](https://towardsdatascience.com/all-about-categorical-variable-encoding-305f3361fd02) 참조
  - Data binning: 반대로 연속형 변수를 범주화하는 방법

- Feature Scaling: 각 변수가 학습에 영향을 미치는 정도를 균일하게 해주는 작업
  - Normalization: 각 변수마다 범위를 0~1로 설정
  - Min-max normalization: 각 변수마다 최소, 최대값을 -1, 1로 각각 설정
  - Standardization: 각 변수가 평균이 0, 표준편차가 1이 되도록 설정

* * *
## 1. 결측 처리(Imputation)
* * *

* * *
## 2. 변수 인코딩(Encoding)
* * *

* * *
# Modeling
* * *

* * *
## 1. 검증 데이터(Validation Data)
* * *

* * *
## 2. Random Forest
* * *

* * *
### 1. Boosting models: XGBoost
* * *

* * *
### 2. Boosting models: LGBoost
* * *

* * *
## 3. Support Vector Machine
* * *

* * *
## 4. 앙상블(Ensemble)
* * *

* * *
# Evaluation
* * *